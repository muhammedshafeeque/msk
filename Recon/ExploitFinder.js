// Exploit Finder & Fetcher - Exploit Database Integration
import chalk from 'chalk';
import mistral from '../Config/Mistra.js';
import fs from 'fs/promises';

class ExploitFinder {
  constructor() {
    this.exploitSources = {
      'exploit-db': 'https://www.exploit-db.com/search?q=',
      'rapid7': 'https://www.rapid7.com/db/search?q=',
      'nvd': 'https://nvd.nist.gov/vuln/detail/',
      'cve-mitre': 'https://cve.mitre.org/cgi-bin/cvename.cgi?name='
    };
    
    this.foundExploits = [];
  }

  async findExploits(vulnData) {
    console.log(chalk.bgBlue.white(`\n💥 Exploit Finder & Fetcher - Searching Exploits`));
    
    const exploits = [];
    
    // Process each vulnerability
    for (const vuln of vulnData.vulnerabilities || []) {
      const vulnExploits = await this.searchForExploits(vuln);
      exploits.push(...vulnExploits);
    }
    
    // Remove duplicates
    const uniqueExploits = this.removeDuplicateExploits(exploits);
    
    // Sort by availability and type
    uniqueExploits.sort((a, b) => {
      const typeOrder = { 'public': 1, 'metasploit': 2, 'proof_of_concept': 3, 'theoretical': 4 };
      return typeOrder[a.type] - typeOrder[b.type];
    });
    
    this.foundExploits = uniqueExploits;
    
    console.log(chalk.green(`✅ Found ${uniqueExploits.length} unique exploits`));
    
    return uniqueExploits;
  }

  async searchForExploits(vuln) {
    const exploits = [];
    
    // Search for exploits based on CVE
    if (vuln.cve) {
      const cveExploits = await this.searchCVEExploits(vuln.cve);
      exploits.push(...cveExploits);
    }
    
    // Search for exploits based on technology and version
    const techExploits = await this.searchTechnologyExploits(vuln.technology, vuln.detected_version);
    exploits.push(...techExploits);
    
    return exploits;
  }

  async searchCVEExploits(cve) {
    const exploits = [];
    
    // Simulate exploit database search results
    const exploitDatabase = {
      'CVE-2021-41773': [
        {
          id: 'EDB-50406',
          title: 'Apache 2.4.49 - Path Traversal',
          type: 'public',
          source: 'exploit-db',
          url: 'https://www.exploit-db.com/exploits/50406',
          description: 'Path traversal vulnerability in Apache 2.4.49',
          difficulty: 'Easy',
          verified: true
        },
        {
          id: 'MSF-2021-41773',
          title: 'Apache 2.4.49 Path Traversal',
          type: 'metasploit',
          source: 'metasploit',
          url: 'https://github.com/rapid7/metasploit-framework/blob/master/modules/exploits/unix/webapp/apache_normalize_path.rb',
          description: 'Metasploit module for Apache path traversal',
          difficulty: 'Easy',
          verified: true
        }
      ],
      'CVE-2021-29447': [
        {
          id: 'EDB-50033',
          title: 'WordPress 5.7 - Object Injection',
          type: 'public',
          source: 'exploit-db',
          url: 'https://www.exploit-db.com/exploits/50033',
          description: 'Object injection vulnerability in WordPress',
          difficulty: 'Medium',
          verified: true
        }
      ],
      'CVE-2021-21708': [
        {
          id: 'EDB-49933',
          title: 'PHP 7.4 - Use After Free',
          type: 'proof_of_concept',
          source: 'exploit-db',
          url: 'https://www.exploit-db.com/exploits/49933',
          description: 'Use after free vulnerability in PHP',
          difficulty: 'Hard',
          verified: false
        }
      ]
    };
    
    if (exploitDatabase[cve]) {
      exploits.push(...exploitDatabase[cve]);
    }
    
    return exploits;
  }

  async searchTechnologyExploits(technology, version) {
    const exploits = [];
    
    // Simulate technology-specific exploit search
    const techExploits = {
      'WordPress': [
        {
          id: 'WP-EXPLOIT-001',
          title: 'WordPress Plugin Vulnerability Scanner',
          type: 'public',
          source: 'custom',
          url: 'https://github.com/wpscanteam/wpscan',
          description: 'WPScan for WordPress vulnerability scanning',
          difficulty: 'Easy',
          verified: true
        }
      ],
      'Apache': [
        {
          id: 'APACHE-EXPLOIT-001',
          title: 'Apache Configuration Scanner',
          type: 'public',
          source: 'custom',
          url: 'https://github.com/apache/httpd',
          description: 'Apache configuration analysis tools',
          difficulty: 'Medium',
          verified: true
        }
      ],
      'MySQL': [
        {
          id: 'MYSQL-EXPLOIT-001',
          title: 'MySQL Weak Password Scanner',
          type: 'public',
          source: 'custom',
          url: 'https://github.com/rapid7/metasploit-framework/blob/master/modules/auxiliary/scanner/mysql/mysql_login.rb',
          description: 'MySQL authentication testing',
          difficulty: 'Easy',
          verified: true
        }
      ]
    };
    
    if (techExploits[technology]) {
      exploits.push(...techExploits[technology]);
    }
    
    return exploits;
  }

  removeDuplicateExploits(exploits) {
    const seen = new Set();
    return exploits.filter(exploit => {
      const key = `${exploit.id}-${exploit.source}`;
      if (seen.has(key)) {
        return false;
      }
      seen.add(key);
      return true;
    });
  }

  async generateExploitReport(vulnData) {
    console.log(chalk.cyan(`\n📊 Generating Exploit Report...`));
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportDir = `./reports/${vulnData.target || 'exploit_finder'}_${timestamp}`;
    
    try {
      await fs.mkdir(reportDir, { recursive: true });
      
      // Generate AI-powered exploit analysis
      const aiAnalysis = await this.generateAIExploitAnalysis();
      
      // Exploit finder report
      const exploitReport = {
        target: vulnData.target,
        timestamp: new Date().toISOString(),
        total_exploits: this.foundExploits.length,
        public_exploits: this.foundExploits.filter(e => e.type === 'public').length,
        metasploit_modules: this.foundExploits.filter(e => e.type === 'metasploit').length,
        proof_of_concepts: this.foundExploits.filter(e => e.type === 'proof_of_concept').length,
        exploits: this.foundExploits,
        ai_analysis: aiAnalysis
      };
      
      await fs.writeFile(`${reportDir}/exploit_finder.json`, JSON.stringify(exploitReport, null, 2));
      
      // Markdown exploit report
      const markdownReport = `# Exploit Finder Report: ${vulnData.target}

## Executive Summary
- **Target**: ${vulnData.target}
- **Analysis Date**: ${new Date().toISOString()}
- **Total Exploits Found**: ${this.foundExploits.length}
- **Public Exploits**: ${exploitReport.public_exploits}
- **Metasploit Modules**: ${exploitReport.metasploit_modules}
- **Proof of Concepts**: ${exploitReport.proof_of_concepts}

## Public Exploits
${this.foundExploits.filter(e => e.type === 'public').map(exploit => `
### ${exploit.title}
- **ID**: ${exploit.id}
- **Source**: ${exploit.source}
- **URL**: ${exploit.url}
- **Description**: ${exploit.description}
- **Difficulty**: ${exploit.difficulty}
- **Verified**: ${exploit.verified ? 'Yes' : 'No'}
`).join('')}

## Metasploit Modules
${this.foundExploits.filter(e => e.type === 'metasploit').map(exploit => `
### ${exploit.title}
- **ID**: ${exploit.id}
- **Source**: ${exploit.source}
- **URL**: ${exploit.url}
- **Description**: ${exploit.description}
- **Difficulty**: ${exploit.difficulty}
- **Verified**: ${exploit.verified ? 'Yes' : 'No'}
`).join('')}

## Proof of Concepts
${this.foundExploits.filter(e => e.type === 'proof_of_concept').map(exploit => `
### ${exploit.title}
- **ID**: ${exploit.id}
- **Source**: ${exploit.source}
- **URL**: ${exploit.url}
- **Description**: ${exploit.description}
- **Difficulty**: ${exploit.difficulty}
- **Verified**: ${exploit.verified ? 'Yes' : 'No'}
`).join('')}

## Exploit Distribution by Type
${this.getExploitDistribution()}

## AI-Powered Exploit Analysis
${aiAnalysis}
`;
      
      await fs.writeFile(`${reportDir}/exploit_report.md`, markdownReport);
      
      console.log(chalk.green(`\n📊 Exploit finder reports generated in: ${reportDir}`));
      return reportDir;
    } catch (err) {
      console.log(chalk.red(`Exploit report generation failed: ${err.message}`));
    }
  }

  getExploitDistribution() {
    const distribution = {};
    
    this.foundExploits.forEach(exploit => {
      if (!distribution[exploit.type]) {
        distribution[exploit.type] = 0;
      }
      distribution[exploit.type]++;
    });
    
    return Object.entries(distribution).map(([type, count]) => `
### ${type.charAt(0).toUpperCase() + type.slice(1)}
- **Count**: ${count}
`).join('');
  }

  async generateAIExploitAnalysis() {
    const prompt = `Analyze the following found exploits and provide detailed insights:

Exploits: ${JSON.stringify(this.foundExploits, null, 2)}

Please provide:
1. Exploit Availability Assessment (how many exploits are available)
2. Exploitation Complexity Analysis (difficulty of using these exploits)
3. Risk Assessment (how dangerous are these exploits)
4. Exploitation Recommendations (which exploits to prioritize)
5. Mitigation Strategies (how to protect against these exploits)
6. Exploitation Timeline (realistic timeline for exploitation)

Format as markdown with clear sections and actionable insights.`;

    try {
      const aiResult = await mistral.chat.complete({
        model: "mistral-large-latest",
        messages: [{ role: "user", content: prompt }]
      });
      return aiResult.choices?.[0]?.message?.content;
    } catch (err) {
      return `AI exploit analysis failed: ${err.message}`;
    }
  }

  async processVulnData(vulnData) {
    console.log(chalk.bgBlue.white(`\n💥 Exploit Finder & Fetcher - Processing Vulnerability Data`));
    
    // Find exploits
    const exploits = await this.findExploits(vulnData);
    
    // Generate report
    const reportDir = await this.generateExploitReport(vulnData);
    
    console.log(chalk.bgGreen.white(`\n✅ Exploit Finder & Fetcher completed!`));
    console.log(chalk.yellow(`📁 Reports saved to: ${reportDir}`));
    
    return {
      exploits: exploits,
      report_directory: reportDir
    };
  }
}

export { ExploitFinder }; 